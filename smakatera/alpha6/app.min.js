const KeyLayouts = {
    Arrows: 1,
    WASD: 2,
    Numpad:3,
    UHJK:4,
    valid: function (m) {
        return m === this.Arrows || m === this.WASD ||m === this.Numpad || m===this.UHJK;
    }
};
Object.freeze(KeyLayouts);

const Directions = {
    Left: 1,
    Right: 2,
    Up: 3,
    Down: 4,
    valid: function (d) {
        return d === this.Left || d === this.Right || d === this.Up || d === this.Down;
    },
    opposite(d1, d2) {
        return (d1 == this.Left && d2 == this.Right) || (d1 == this.Right && d2 == this.Left) ||
            (d1 == this.Up && d2 == this.Down) || (d1 == this.Down && d2 == this.Up);
    }
};
Object.freeze(Directions);

class Player extends Snake {
    constructor(r, v) {
        super(r, v);
        this.score = 0;
        this.alive = true;
        this.settings = {
            snakeColor: "#22af00",
            keyLayout: KeyLayouts.Arrows
        };
        this.TurnLeft();
        this.hash = Utils.Hash16(8);
    }
    AttachController(c) {
        if (!c instanceof BaseController) {
            throw "it's not a controller";
        }
        this.controller = c;
    }
    OnKey (key){
        this.controller.OnKey(this,key);
    }
    SetScore(s) {
        if (!Utils.IsWholeNumber(s)) {
            throw "Whole number needed";
        }
        this.score =s;
    }
    Die(){
        this.alive = false;
    }
    Reanimate(){
        this.alive = true;
    }
    RandomJump(canvas){
        let x = Math.floor(Math.random() * (canvas.width));
        let y = Math.floor(Math.random() * (canvas.height));
        let distance_required = this.radius * 4
        if (x < distance_required) {
            x =  distance_required
        }
        if (x > (canvas.width - distance_required)) {
            x = canvas.width - distance_required;
        }
        if (y < distance_required) {
            y =  distance_required;
        }
        if (y > (canvas.height - distance_required)) {
            y = canvas.height - distance_required;
        }
        this.SetHeadPosition(x,y);
    }
    GetScore() {
        return this.score;
    }
    ScoreOne() {
        let s = this.GetScore();
        s++;
        this.SetScore(s);
    }
    Draw(rc, snakeGame) {
        super.Draw(rc, snakeGame);
    }
    /**
     * @returns {Direction}
     */
    GetDirection() {
        return this.direction;
    }
    /**
     * changes a direction
     * @param {Direction} d 
     */
    UpdateDirection(d) {
        if (!Directions.valid(d)) {
            throw "Error: not a valid direction";
        }
        this.lastDirection = this.direction;
        this.direction = d;
        this.QuickSwitch();
    }
    TurnUp(){
        this.UpdateDirection(Directions.Up);
    }
    TurnLeft(){
        this.UpdateDirection(Directions.Left);
    }
    TurnDown(){
        this.UpdateDirection(Directions.Down);
    }
    TurnRight(){
        this.UpdateDirection(Directions.Right);
    }
    /**
     * update player
     * @param {Food} food 
     * @param {Canvas} canvas 
     * @param {SnakeGame} game 
     */
    Update(food, canvas,game) {
        if(!this.alive){
            return;
        }
        const poslen = this.positions.length;

        const current = this.GetDirection();
        const { velocity } = this; 

        //follow head
        for (let i = poslen - 1; i > 0; i--) {
            this.positions[i].x = this.positions[i - 1].x;
            this.positions[i].y = this.positions[i - 1].y;
        }
        
        let { x, y } = this.GetHeadPosition();
        if (current == Directions.Right) { this.SetHeadPosition(x + velocity); }
        if (current == Directions.Left) { this.SetHeadPosition(x - velocity); }
        if (current == Directions.Up) { this.SetHeadPosition(null, y - velocity); }
        if (current == Directions.Down) { this.SetHeadPosition(null, y + velocity); }

        //free bound
        this.FreeBound(canvas,game);
        this.Colision(game);
        this.Eat(food, canvas);
    }
    /**
     * this fixes crashin when quickly switching direction to opposite
     */
    QuickSwitch() {
        // debugger;
        const ld = this.lastDirection;
        const d = this.direction;
        if (ld !== undefined) {
            if (Directions.opposite(d, ld)) {
                this.positions.reverse();
            }
        }
        
    }
    Eat(food, canvas) {
        if (food === null){
            return;
        }
        let { x, y } = this.GetHeadPosition();
        //eat food
        if (distance(x, y, food.x, food.y) < this.radius * 2) {
            food.Renew(canvas);
            // this.ScoreOne();
            this.score++;
            this.AddMass();
        }
    }
    /**
     * free bound:  snake moves over bounds
     * @param {HTMLElement} canvas 
     * @param {SnakeGame} game 
     * @param {Boolean} force 
     */
    FreeBound(canvas,game,force) {
        if (game.settings.freeBound || force) {
            let { x, y } = this.GetHeadPosition();
            if (x < 0) this.SetHeadPosition(canvas.width, null);
            if (x > canvas.width) this.SetHeadPosition(0, null);
            if (y < 0) this.SetHeadPosition(null, canvas.height);
            if (y > canvas.height) this.SetHeadPosition(null, 0);
            return;
        }
        this.BoundsCheck(canvas,game);
    }
    BoundsCheck(canvas,game) {
        let { x, y } = this.GetHeadPosition();
        if (x < 0 || x > canvas.width || y < 0 || y > canvas.height) {
            // debugger;
            this.Die();
            return;
        }
        for (let i = 1, len = this.positions.length; i < len; i++) {
            let p = this.positions[i];
            if (p.x == x && p.y == y) {
                this.Die();
                return;
            }
        }
    }
    Colision(snakeGame) {
        if (snakeGame.entityList.length < 2) {
            return;
        }
        if (snakeGame.settings.moveOver) {
            return;
        }
        const coords = this.GetHeadPosition();
        let x1 = coords.x;
        let y1 = coords.y;
        for(const e of snakeGame.entityList){
            if(e.hash == this.hash){
                continue;
            }            
            
            let {x,y} = e.GetHeadPosition();
            //if head to head both die
            if(Utils.Distance(x1,y1,x,y)<this.radius){
                this.Die();
                e.Die();
                return;
            }
            //the one who hits head, it dies
            for (const p of e.positions) {
                let { x, y } = p;
                if (x1 == x && y1 == y) {
                    this.Die();
                }
            }
            // if (x == x1 && y == y1) { }
        }
    }
}class ActionController {
    constructor(g) {
        // if (!g instanceof SnakeGame) {
        //     throw "improper object";
        // }
        // this.game = g;
    }
    // Action(a, event) {

    // }
    // GoFullScreen() { }
    // Pause() { }
    // Resume() { }
    // DisplayMenu() { }
    // CloseMenu() { }
}

class KeyBoardController extends ActionController {
    constructor() {
        super();
    }
    Setup(snakeGame) {
        document.body[on]("keydown", this.OnKeyDown.bind(this, snakeGame));
    }
    OnKeyDown(snakeGame, e) {
        //debugger;
        const { key } = e;
        switch (key) {
            case "f":
            case "F":
                snakeGame.GoFullScreen();
                break;
            case "z":
            case "Z":
                snakeGame.Pause();
                break;
            case "r":
            case "R":
                snakeGame.Resume();
                break;
            case "m":
            case "M":
                snakeGame.DisplayMenu();
                break;
            case "n":
            case "N":
                // debugger;
                snakeGame.CloseMenu();
                break;
            case "x":
            case "X":
                // snakeGame.Restart();
                break;
            default:
                snakeGame.KeyEvent(key);
        }
    }
}

class OnScreenControls extends ActionController {
    constructor() {
        super();
    }
    /**
     * 
     * @param {SnakeGame} snakeGame 
     */
    Setup(snakeGame) {
        // debugger;
        let buttons = document.body.querySelectorAll('button');

        for (let i = 0, len = buttons.length; i < len; i++) {
            buttons[i][on]("click", this.OnScreenEvent.bind(this, snakeGame));
        }
    }
    /**
     * 
     * @param {SnakeGame} snakeGame 
     * @param {Event} e 
     */
    OnScreenEvent(snakeGame, e) {
        // debugger;
        let key = e.target.getAttribute("data-app-action");
        switch (key) {
            case "fullscreen":
                snakeGame.GoFullScreen();
                break;
            case "new":
                snakeGame.DisplayNewGameMenu();
                break;
            case "restart":
                snakeGame.Restart();
                break;
            case "settings":
                snakeGame.DisplayMenu();
                break;
            default:
                snakeGame.KeyEvent(key);
        }
    }
}class BaseController {
    constructor(){}
    Left(p){
        p.TurnLeft();
    }
    Right(p){
        p.TurnRight();
    }
    Up(p){
        p.TurnUp();
    }
    Down(p){
        p.TurnDown();
    }
}

class ArrowsController  extends BaseController{
    constructor(){
        super();
    }
    OnKey(p,k){
        switch(k){
            case "ArrowUp":
                super.Up(p);
                break;
            case "ArrowLeft":
                super.Left(p);
                break;
            case "ArrowDown":
                super.Down(p);
                break;
            case "ArrowRight":
                super.Right(p);
                break;
        }
    }
}
class WasdController  extends BaseController{
    constructor(){
        super();
    }
    OnKey(p,k){
        switch(k){
            case "w":
            case "W":
                super.Up(p);
                break;
            case "a":
            case "A":
                super.Left(p);
                break;
            case "s":
            case "S":
                super.Down(p);
                break;
            case "d":
            case "D":
                super.Right(p);
                break;
        }
    }
}

class NumpadController extends BaseController {
    OnKey(p,k){
        switch(k){
            case "8":
                super.Up(p);
                break;
            case "4":
                super.Left(p);
                break;
            case "5":
                super.Down(p);
                break;
            case "6":
                super.Right(p);
                break;
        }
    }
}

class UhjkController extends BaseController {
    OnKey(p,k){
        switch(k){
            case "u":
            case "U":
                super.Up(p);
                break;
            case "h":
            case "H":
                super.Left(p);
                break;
            case "j":
            case "J":
                super.Down(p);
                break;
            case "k":
            case "K":
                super.Right(p);
                break;
        }
    }
}
////
class UIController {
    constructor() { }
    static DisplayScore(game, context, canvas) {
        context.fillStyle = "black";//user setting
        let  _text = "|";
        for (const e of game.entityList) {
            _text = _text.concat(`-Score:${e.score}-|`);
        }
        context.beginPath();
        context.font = "22px Arial";
        context.fillText(_text, canvas.width - (24 * _text.length), 30);
        context.closePath();
    }
    static DisplayFPS(game, context, canvas, avg) {
        if (game.settings.enablefps !== true) {
            return;
        }
        context.fillStyle = "black";
        const _time = Date.now();
        let fps = Math.round((1000 / (_time - game.timer1)));
        game.timer1 = _time;
        context.beginPath();
        context.font = "16px Arial";
        context.fillText(`${fps} FPS`, canvas.width-60, 30);
        context.closePath();
    }
    static DisplayTime(context, game) {
        if (game.timed !== true) {
            return;
        }
        context.fillStyle = "black";
        context.beginPath();
        context.font = "16px Arial";
        context.fillText(`Time: ${game.time}`, 100, 30);
        context.closePath();
    }
    static Alert(msg) {
        PopAlert.OPEN(msg,"OK");
    }
    static DisplayWelcomeScreen(context) {
        context.fillStyle = "black";
        context.beginPath();
        context.font = "24px Arial";
        context.fillText(`Welcome to Smake game`, 300, 60);
        context.fillText("use arrow keys to navigate", 300, 100);
        context.fillText("Press 'z' to pause game, 'r' to resume, f or F to fullscreen", 300, 140);
        context.fillText("'m' to display settings dialog , 'n' to close that dialog", 300, 180);
        context.closePath();
    }
    static DisplayMultiPlayerControls(context){
        context.fillStyle = "black";
        context.beginPath();
        context.font = "20px Arial";
        context.fillText("Your are playing local machine mulitplayer", 300, 210);
        context.fillText("Game supports up to 4 players",300,240);
        context.fillText("First player uses Arrow controls",300,270);
        context.fillText("Second Player uses WASD controls",300,300);
        context.fillText("Third player can use numpad (must be present on keyboard)",300,330);
        context.fillText("With following controls : 8-UP, 4-LEFT, 5-Down, 6-RIGHT",300,360);
        context.fillText("4th player can use UHJK keys ",300,390);
        context.fillText("with following controls : U-UP, H-LEFT, J-DOWN, K-RIGHT",300,420);
        context.fillText("Press 'z' to pause game, 'r' to resume, f or F to fullscreen", 300, 450);
        context.fillText("'m' to display settings dialog , 'n' to close that dialog", 300, 480);
        context.closePath();
    }
}const Modes = {
    Long: 1,
    Endurance: 2,
    Challenge: 3,
    valid: function (m) {
        // return m === this.Long || m === this.Endurance || m === this.Challenge;
        for(const l in this){
            if (typeof m !=="function" && m===this[l]){return true;}
        }
        return false;
    }
};
Object.freeze(Modes);
const Languages = {
    English:1,
    Georgian:2,
    German:3,
    valid: function (m) {
        for(const l in this){
            if (typeof m !=="function" && m===this[l]){return true;}
        }
        return false;
    }
}
Object.freeze(Languages);

const Level = new Enumer(["Easy","Normal","Hard","Master"]);

class SnakeGame {
    /**
     * @param {Modes} _mode 
     * @param {Canvas} _canvas 
     * @param {RenderingContext} rc
     */
    constructor(_mode, _canvas, rc) {
        this.timer1 = Date.now();
        this.score = 0;
        this.metrics = {};//fps
        this.canvas = _canvas;
        this.settings = {
            enablefps: true,
            freeBound: true,
            moveOver:false,
            foodColor: "#ff2af0",
            snakeColor: "#22af00"
        };
        this.timerid = null;
        this.renderingContext = rc;
        this.entityList = [];
        this.SetMode(_mode);
        //this.level = "easy";
    }
    AddEntities(someEntity) {
        if (!someEntity instanceof Snake || someEntity instanceof Food) {
            throw "not a valid entity";
        }
        this.entityList.push(someEntity);
    }
    NewGame(n,s) {
        this.timerid =null;
        // debugger;
        if (typeof s === "object") {
            this.UpdateSettings(s);
            this.SetMode(Modes[s.mode]);
            this.SetLevel(s.level);
        }       

        this.entityList = [];
        this.ClearTimers();

        let x = this.canvas.width/2;
        let y = this.canvas.height/2;
        let color = "black";
        let ctl = new ArrowsController();
        this.CreatePlayer({x,y},color,ctl);
        if (n>1){
            let x = this.canvas.width/4;
            let y = this.canvas.height/4;
            let color = "green";
            let ctl = new WasdController();
            this.CreatePlayer({x,y},color,ctl);
        }
        if (n>2){
            let x = this.canvas.width/2;
            let y = this.canvas.height/4;
            let color = "orange";
            let ctl = new NumpadController();
            this.CreatePlayer({x,y},color,ctl);
        }
        if (n>3){
            let x = this.canvas.width/4;
            let y = this.canvas.height/2;
            let color = "blue";
            let ctl = new UhjkController();
            this.CreatePlayer({x,y},color,ctl);
        }
        let x1 = this.canvas.width/4;
        let y1 = this.canvas.height/2;
        let food = new Food(x1,y1,12);
        //this.AddEntities(food);
        this.food = food;
        this.food.Renew(this.canvas);
        this.Pause();
    }
    Restart() {
        // debugger;
        this.Pause();
        const { canvas} = this;
        for (const e of this.entityList){
            if (e instanceof Player){
                e.Shrink();
                //this doesn't work if players have colided
                e.FreeBound(canvas,this,true);
                e.RandomJump(canvas);
                e.SetScore(0);
                e.Reanimate();
            }
        }
        this.gameover = false;
        this.alerted = false;
        this.Resume();
    }
    /**
     * creates snake
     * @param {Color} c 
     * @param {Position} p 
     */
    CreatePlayer(p,c,controls) {
        let velocity = this.SelectVelocity();
        const player = new Player(12, velocity);
        player.SetHeadPosition(p.x, p.y);
        player.UpdateColor(c);
        player.AttachController(controls);
        this.AddEntities(player);
    }
    SelectVelocity(){
        let v = 0;
        switch (this.level) {
            case Level.Easy:
                v = 2;
                break;
            case Level.Normal:
                v = 4;
                break;
            case Level.Hard:
                v = 6;
                break;
            case Level.Master:
                v = 8;
                break;
            default:
                v = 4;
        }
        return v;
    }
    SetMode(m) {
        if (!Modes.valid(m)) {
            throw "Not a valid mode";
        }
        this.mode = m;
    }
    SetLevel(l){
        if(!Level.valid(l)){
            throw "Not a valid level";
        }
        this.level = l;
    }
    Start() {
        //"r" key to start or resume game
    }
    ClearTimers (){
        if (this.timerid !== null) {
            window.clearInterval(this.timerid);
            this.timerid = null;
        }
        
    }
    GetInterval(){
        let i = 20;
        switch (this.level) {
            case Level.Easy:
                i = 20;
                break;
            case Level.Normal:
                i = 10;
                break;
            case Level.Hard:
            case Level.Master:
                i = 5;
                break;
            default:
                i = 10;
        }
        return i;
    }
    /**
     * Endurance : you gain [point and] mass in every 20 seconds, your intent is to last longer
     * easy every 20 seconds
     * medium every 10 seconds
     * hard every 5 seconds
     * master 5 second and point isn't given for gained mass you need to eat food (only level to feature food);
     */
    EnduranceMode() {
        if (this.timerid !== null) {
            return;
        }
        let interval = this.GetInterval()*1000;
        if(this.level !== Level.Master){
            this.food = null;
        }

        this.timerid = window.setInterval(() => {
            //debugger;
            const { canvas } = this;
            if (this.gameover) {
                window.clearInterval(this.timerid);
                this.timerid = null;
                return;
            }
            if (this.pause){
                return;
            }
            for (const e of this.entityList) {
                if (e instanceof Player) {
                    e.AddMass();
                    if (this.level !== Level.Master) e.score++;
                }
            }

            //in two player mode if one dies other wins
        }, interval);
        // 
    }
    ChallengeMode() {
        //challenge mode
        //fruits are dropped and have limited time to be eaten
        //easy if miss no penalty
        //medium if miss penalty on score 5 point (positive constraint)
        //hard if miss warning , loss of tail (3 positions)
        //in multi player who eats pardon, who don shrink
    }
    GetFrame() {
        // if all are dead, then end game
        let i = 0;
        for (const e of this.entityList) {
            if (!e.alive) { i++ };
        }
        if (i === this.entityList.length) {
            this.gameover = true;
            return;
        }
        // debugger;
        let dis = this;
        const renderctx = this.renderingContext;
        const canvas = this.canvas;

        renderctx.clearRect(0,0,canvas.width,canvas.height);

        for (const e of this.entityList){
            if (e instanceof Player){
                e.Update(this.food,canvas,dis);
            }
        }
        //after all entities got update //then draw
        for (const e of this.entityList){
            if (e instanceof Player){
                e.Draw(renderctx,this);
            }
        }
        if(this.food !==null){
            this.food.Draw(renderctx,this);
        }        
        UIController.DisplayFPS(this,renderctx,canvas);        
        UIController.DisplayScore(this,renderctx,canvas);
    }
    KeyEvent(key){
        for (const e of this.entityList){
            if (e instanceof Player){
                e.OnKey(key);
            }
        }
    }
    Pause() {
        this.pause = true;
    }
    Resume() {
        // debugger;
        if (this.mode=== Modes.Endurance){
            this.EnduranceMode();
        }
        this.pause = false;
    }
    GoFullScreen() {
        //debugger;
        let { canvas } = this;
        canvas.requestFullscreen();
    }
    DisplayFPS(){

    }
    DisplayScore(){

    }
    DisplayMultiControls(){
        const {renderingContext} = this;
        UIController.DisplayMultiPlayerControls(renderingContext); 
    }
    DisplayNewGameMenu(){
        NewGameDialog.Open(this);
    }
    CloseMenu(){       
        SettingsDialog.Close(this);
    }
    DisplayMenu() {
        SettingsDialog.Open(this);
    }
    UpdateSettings(s){
        if (typeof s !=="object"){
            throw "UpdateSettings:not an object";
        }
        for(const f in s){
            if(this.settings[f] === undefined){
                console.log(`UpdateSettings: ${f} not a setting, skipping`);
                continue;
            }
            this.settings[f] = s[f];
        }
    }
}// game modes
// speed 4,6,8,10 - as 1,2,3,4

//fps count
//default 5 frame average, every 5th frame count and display
//user settings applied

try{
    const canvas = document.getElementById("canvas1");
    const context = canvas.getContext("2d");

    let style = window.getComputedStyle(canvas.parentElement);
    canvas.width = style.width.replace("px", ""); //*0.95;
    canvas.height = style.height.replace("px", ""); //*0.95;

    canvas[on]("fullscreenchange",(e)=>{
        if (document.fullscreenElement){
            window.savedCanvasWidth = canvas.width;
            window.savedCanvasHeight = canvas.height;
            canvas.width = window.screen.width;
            canvas.height = window.screen.height;
        }else{
            canvas.width = window.savedCanvasWidth;
            canvas.height = window.savedCanvasHeight;
        }        
    })
    context.imageSmoothingEnabled = true;

    const snakeGame = new SnakeGame(Modes.Long,canvas,context);
    snakeGame.NewGame(1,undefined);

    if(window.innerWidth <800){
        snakeGame.settings.scale =  (window.innerWidth / 1280);
        snakeGame.settings.scaleEnabled = true;
        document.getElementById("new").textContent = "";
        document.getElementById("restart").textContent = ""; 
    }
    snakeGame.alerted = false;

    const get_frame =()=>{
        if(snakeGame.gameover){            
            if(!snakeGame.alerted){
                UIController.Alert("Game Over!");
                snakeGame.alerted = true;
            }
            requestAnimationFrame(get_frame);
            return;
        }

        if(snakeGame.gameover || snakeGame.pause){
            requestAnimationFrame(get_frame);
            return;
        }
        
        snakeGame.GetFrame();
        requestAnimationFrame(get_frame);
    }
    query("#fullscreen")[on]("click",()=>{
        canvas.requestFullscreen();
    });
    snakeGame.Pause();

    snakeGame.GetFrame();
    
    const kb1 = new KeyBoardController();
    kb1.Setup(snakeGame);

    const osc = new OnScreenControls();
    osc.Setup(snakeGame);

    if(window.innerWidth > 1000){
        UIController.DisplayWelcomeScreen(context);
    }

    requestAnimationFrame(get_frame);
}catch(e){
    console.log(e);
    console.log(e.message);
}finally{

}//Build Date : 2022-07-27T08:33+04:00